## 23种设计模式示例与说明

设计模式是一些被广泛应用的思想模型，它们描述了有效、可靠的软件设计和实现方法，可以在面对复杂的软件架构和问题时提供指导思路。
23种设计模式可以分为三类，每一类的模式解决了一个特定的问题：


1. 创建型模式
   这类模式关注对象的创建过程，用于隔离对象创建的复杂性，提供了创建对象的最佳实践方式。
   共有5种设计模式属于这一类：

- 工厂方法模式（Factory Method Pattern）：定义一个用于创建对象的接口，让子类决定实例化哪一个类。
- 抽象工厂模式（Abstract Factory Pattern）：提供一个接口，用于创建相关或依赖对象族的一组对象，而无需明确指定具体类。
- 单例模式（Singleton Pattern）: 保证一种类型的对象只有一个实例，并且提供一个访问它的全局访问点。
- 建造者模式（Builder Pattern）: 将一个复杂对象的构建和表示分离，使得同样的构建过程可以创建不同的表现形式。
- 原型模式（Prototype Pattern）：通过复制现有的实例来创建新实例。

2. 结构型模式
   这类模式关注对象的组合方式，用于处理不同类之间的关系，以及在对象之间构建简洁、清晰的结构。
   共有7种设计模式属于这一类：

- 适配器模式（Adapter Pattern）：将不兼容的类组合起来，以满足不同类之间的需求。
- 桥接模式（Bridge Pattern）：将一个抽象与实现解耦，以便两者独立地变化。
- 组合模式（Composite Pattern）：将对象组合成树形结构来表示部分和整体的层次关系。
- 装饰模式（Decorator Pattern）：动态地将责任附加到对象上，以扩展其功能。/在保证访问原有接口A方式不变的情况下，对接口A进行功能扩展  
- 外观模式（Facade Pattern）：为复杂的子系统提供一个简单的接口。/通过一个傻瓜操作访问一个复杂功能，无需知道内部实现  
- 享元模式（Flyweight Pattern）：通过共享细粒度的对象来减少内存的使用。/通过对象复用避免频繁创建对象  
- 代理模式（Proxy Pattern）：为其他对象提供一种代理以控制对这个对象的访问。

3. 行为型模式
   这类模式关注对象之间的交互方式，用于处理不同类之间的通讯和流程，以及在对象之间构建可维护、可扩展的关系。
   共有11种设计模式属于这一类：

- 职责链模式（Chain of Responsibility Pattern）：将请求的发送者和接收者解耦，并将其链接成一条链以处理请求。/一系列操作抽象成拥有共同父类的处理者们，前一个处理完自动调用后一个处理  
- 命令模式（Command Pattern）：将一个请求封装成一个对象，从而使您可以使用不同的请求来参数化客户对象。/不同的请求封装成不同命令，通过给调用者设置不同命令，再由各命令调用各自实际命令执行者执行。  
- 解释器模式（Interpreter Pattern）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。/定义一个简单表达式，然后赋值递归解释该表达式  
- 迭代器模式（Iterator Pattern）：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。
- 中介者模式（Mediator Pattern）：用一个中介对象封装一系列的对象交互，从而使得各对象不需要显式地相互作用。
- 备忘录模式（Memento Pattern）：在不违反封装原则的情况下，捕获一个对象的内部状态，并在该对象需要恢复时将其恢复到先前的状态。
- 观察者模式（Observer Pattern）：定义了对象之间的一对多依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
- 状态模式（State Pattern）：允许对象在状态发生改变时改变其行为。目的是将状态与行为分离，从而减少相互依赖。/对象的几种不同状态及各自行为提取成单独的对象，通过环境中设置状态并执行来实现不同状态触发不同行为的功能  
- 策略模式（Strategy Pattern）：定义一系列算法，将它们一一封装起来，并且使它们可以相互替换。
- 模板方法模式（Template Method Pattern）：定义了一个操作中的算法的骨架，将一些步骤延迟到子类中。从而使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。
- 访问者模式（Visitor Pattern）：表示一个作用于某个对象结构中的各元素的操作，使得可以在不改变各元素的类的前提下定义作用于这些元素的新操作。/ 同一类元素集合，针对不同访问者访问同一接口返回不同的数据  